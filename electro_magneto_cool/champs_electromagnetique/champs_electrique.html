<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="utf-8">
  <meta name="viewport" content="width=device_width, initial-scale=1.0">

  
	<title>üëÑ‚Üùüé§‚Üùüìà‚Üùüì°‚Üùüì°‚Üùüìà‚Üùüìª‚ÜùüëÇ</title>
  <link rel="icon" type="image/png" href="img_4.png" />
     <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
	<link rel="stylesheet" type="text/css" href="style_electrique.css"> 



</head>

<body id="body">
  <div id="titre_fond"></div>
  <div id="gradient_initial"></div>

  <div>
    <a id="retour" href="index.html">retour</a>
<div id="anim_raquette" class="boite" onclick="apparition_charge()">
<div id="raquette"> </div>
<div id="obj_raquette" class="txt_boite" style="margin-top:-157px;">
  <p> on dit qu'un objet, ou zone de l'espace <br>est √©lectriquement neutre au repos.</p>
</div>
<div id="cercle_baton" style="display: none;">
<div id="cercle_zoom"></div>
<div id="baton"></div></div>
</div>





<div id="charge_neutre" class="boite"  style="display:none; margin-left:100px; margin-top: -88px; width: 300px; height: 210px;">


  <div class="les_charges" onclick="zoom_charge_neutre()" style="pointer-events:none; width:237px; height: 123px; position:absolute;">
  <div id="boite_charge"> 
    <div id="noyau"> </div>

    <p id="charge5" class="charge negatif" style="margin-top: -31px;margin-left: 47px;">-</p>
  <p id="charge6" class="charge negatif" style="margin-top: 95px;margin-left: 88px;">-</p>
  <p id="charge7" class="charge negatif" style="margin-top: 3px;margin-left: 178px;">-</p>
  <p id="charge8" class="charge negatif" style="margin-top: 105px;margin-left: 187px;">-</p>
  <p id="charge1" class="charge positif" style="margin-top: 17px;margin-left: 92px;">+</p>
  <p id="charge2" class="charge positif" style="margin-top: 50px;margin-left: 105px;">+</p>
  <p id="charge3" class="charge positif" style="margin-top: 9px;margin-left: 133px;">+</p>
  <p id="charge4" class="charge positif" style="margin-top: 40px;margin-left: 129px;">+</p>
  


  <div id="txt_souris" class="txt_souris" style=" width: 125px; z-index: 20; visibility: hidden; position: absolute; margin-top: -52px;   text-shadow: 0px 0px 12px #FFFFFF, 0px 0px 12px #FFFFFF,0px 0px 12px #FFFFFF, 0px 0px 12px #FFFFFF;">voir √ßa de plus pr√®s</div>

</div>
</div>
  <!-- <div class="txt_boite les_charges" id="blabla_charge_neutre" onclick="zoom_charge_neutre()" style="pointer-events:none;margin-top: 270px;">
  <p>√† l'√©chelle des atomes qui composent <br>la mati√®re, il y a autant de chages positives<br> (protons) que n√©gatives (√©lectrons).</p>
</div> -->

          <div id="blabla_charge_neutre" onclick="zoom_charge_neutre()">
            <img id="text4" src="img/electron_proton.svg" >
          </div>



<div class="txt_boite" id="blabla_arrache_electron" style="display: none; margin-top: 270px;">
  <p>des √©lectrons sont arrach√©s de la mati√®re, <br> elle devient charg√©e positivement.</p>
</div>


<div>
    <select id="question" onchange="selection()" >
      <option value="" selected>...</option>
      <option value="">frotter le ballon</option>
      <option value="">faire passer un courant electrique</option>
      <option value="">envoyer des rayonnements uv</option>

  </select>
</div>







  <div id="anim_charges" style="display:none;">
    <div id="blabla_haut">
<p> *bouger les charges en les attrappant</p>
           <button id="next" style="height:min-content;" onclick="window.location.href='champs_magnetique.html'">passer aux champs magn√©tiques</button>
    </div>

  <svg id="mysvg" width="750" height="500"></svg>
<div id="blabla_bas">
        <div class="button-container">
          <p>les charges positives cr√©ent un champs electrique autour d'elles, c'est une zone ou d'autres peuvent ressentir cette force.</p>
        <div id="bouton_ajout">
        <button id="toggleElectron">approcher un √©lectron</button>
        <button id="toggleProton" style="display:none">approcher un proton</button>
      </div>
      </div>
    </div>
</div>




<div id="cheveux" style="display:none;">
<div id="cheveux_electrique"></div>
<p>par exemple, les cheveux √©lectrostatiques ont √©t√© d√©charg√©s de leurs electrons par frottement avec un pull. Les cheveux se repoussent entre eux car ils sont charg√©s positivement √† leur surface.</p>
</div>


















<script type="text/javascript">



function apparition_charge(){
  $("#charge_neutre").css("display","block");
  $("#cercle_baton").css("display","block");
   $("#anim_raquette").css("cursor","auto"); 
};


function selection(){
  $("#blabla_charge_neutre").css("display","none");
  $("#obj_raquette").css("display","none");
  $("#question").css("display","none");
  $("#blabla_arrache_electron").css("display","block");
  $("#blabla_charge_neutre").css("display","none");
  $("#raquette").css('background-image','url(img/ballon.gif)');
  $('#charge_neutre').css('cursor', 'zoom-in');
  $('#txt_souris').css('visibility','visible');
    $('.les_charges').css('pointer-events','auto');


    let steps = 10;
    let distance = -500;
    let stepSize = distance / steps; // ~83.33px
    let delay = 300; // en ms
    let currentStep = 0;

    function moveStep() {
      if (currentStep < steps) {
        // Calcul du nouveau top
        let newTop = parseFloat($('.negatif').css('top')) + stepSize;

        // D√©placement instantan√© (sans animation)
        $('.negatif').css('top', newTop + 'px');

        currentStep++;

        // Appel de la prochaine √©tape apr√®s un d√©lai
        setTimeout(moveStep, delay);
      }
    }

    moveStep();
};


function zoom_charge_neutre(){
    $("#anim_charges").css("display","block");

}


  ///////////////////////POSITION texte//////////////////////////////////

$(function() {
 
  $('#body').mousemove(function(e) {
    var x = e.pageX;
    var y = e.pageY;
    var mid = $(window).height();
    var midW =$(window).width()/2;
    // var docHeight = $(document).height();

    $('.txt_souris').css('top', y-158+'px');

    $('.txt_souris').css('left', (x-midW)+'px');

});

});




    // R√©cup√©ration de l'√©l√©ment SVG
    const svg = document.getElementById("mysvg");

    // D√©finition des charges : proton principal, √©lectron et deuxi√®me proton
    const charges = [
      { x: 250, y: 300, sign: 1, elem: null, symbol: null, visible: true },  // Proton principal (rouge) - toujours visible
      { x: 550, y: 300, sign: -1, elem: null, symbol: null, visible: false }, // √âlectron (bleu) - invisible au d√©but
      { x: 400, y: 200, sign: 1, elem: null, symbol: null, visible: false }   // Deuxi√®me proton (rouge) - invisible au d√©but
    ];
    
    // √âtats de visibilit√©
    let electronVisible = false;
    let secondProtonVisible = false;
    let firstProtonClick = true; // Nouvelle variable pour tracker le premier clic sur le proton

    // Cr√©ation des √©l√©ments visuels pour chaque charge
    charges.forEach((c, i) => {
      // Cr√©ation du cercle repr√©sentant la charge
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("r", 10);
      circle.setAttribute("cx", c.x);
      circle.setAttribute("cy", c.y);
      circle.setAttribute("class", c.sign > 0 ? "charge1" : "charge2");
      // Masquer les charges invisibles au d√©but
      if (!c.visible) circle.style.display = "none";
      svg.appendChild(circle);
      c.elem = circle;
      
      // Cr√©ation du symbole + ou - au centre de la charge
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", c.x);
      text.setAttribute("y", c.y);
      text.setAttribute("class", "charge-symbol");
      text.textContent = c.sign > 0 ? "+" : "‚àí";
      // Masquer les symboles des charges invisibles
      if (!c.visible) text.style.display = "none";
      svg.appendChild(text);
      c.symbol = text;
    });

    // Fonction qui calcule le champ √©lectrique en un point (x, y)
    function computeField(x, y) {
      let fx = 0, fy = 0; // Composantes du champ r√©sultant
      charges.forEach(c => {
        if (!c.visible) return; // Ignorer les charges invisibles
        const dx = x - c.x; // Distance horizontale √† la charge
        const dy = y - c.y; // Distance verticale √† la charge
        const distSq = dx * dx + dy * dy; // Distance au carr√©
        if (distSq > 1) { // √âviter division par z√©ro pr√®s de la charge
          const dist = Math.sqrt(distSq);
          const force = c.sign / (distSq * 0.8); // Force avec facteur d'att√©nuation
          fx += force * dx / dist; // Composante x du champ
          fy += force * dy / dist; // Composante y du champ
        }
      });
      return { fx, fy };
    }

    // Tableaux pour stocker les chemins, fl√®ches et points finaux des trajectoires
    const paths = [];
    const arrows = [];
    let positiveTrajectoryEndPoints = []; // Points finaux des trajectoires positives pour comparaison

    // Fonction qui trace une ligne de champ √† partir d'un point donn√©
    function traceLine(x, y, startCharge, maxLength = 120) {
      let points = [`M${x},${y}`]; // D√©but du chemin SVG
      let steps = 150; // Nombre maximum d'√©tapes
      let stepSize = 1.2; // Taille de chaque pas
      let prevDir = null; // Direction pr√©c√©dente pour le lissage
      let currentLength = 0; // Longueur parcourue
      let endPoint = { x, y }; // Point final de la trajectoire

      for (let i = 0; i < steps; i++) {
        // Calcul du champ √©lectrique au point actuel
        const { fx, fy } = computeField(x, y);
        const len = Math.sqrt(fx * fx + fy * fy);
        if (len === 0) break; // Arr√™t si champ nul

        let dx = fx / len; // Direction normalis√©e
        let dy = fy / len;

        // Inversion de direction pour les charges n√©gatives (attraction vs r√©pulsion)
        if (startCharge && startCharge.sign < 0) {
          dx = -dx;
          dy = -dy;
        }

        // Lissage de la trajectoire avec la direction pr√©c√©dente
        if (prevDir) {
          const curveStrength = 0.4; // Force du lissage
          dx = (1 - curveStrength) * prevDir.dx + curveStrength * dx;
          dy = (1 - curveStrength) * prevDir.dy + curveStrength * dy;
          const dlen = Math.sqrt(dx * dx + dy * dy);
          if (dlen > 0) {
            dx /= dlen;
            dy /= dlen;
          }
        }

        // Calcul de la nouvelle position
        const newX = x + dx * stepSize;
        const newY = y + dy * stepSize;

        // V√©rification de la longueur maximale autoris√©e
        currentLength += stepSize;
        if (currentLength > maxLength) break;
        
        x = newX;
        y = newY;
        endPoint = { x, y }; // Mise √† jour du point final

        // Arr√™t si on sort des limites du SVG
        if (x < 0 || x > 800 || y < 0 || y > 600) break;

        // V√©rification de proximit√© avec une charge de signe oppos√©
        let nearOppositeCharge = false;
        charges.forEach(c => {
          if (!c.visible) return;
          const dist = Math.sqrt((x - c.x) * (x - c.x) + (y - c.y) * (y - c.y));
          if (dist < 15 && c.sign !== startCharge.sign) {
            nearOppositeCharge = true;
          }
        });
        if (nearOppositeCharge) break; // Arr√™t si trop proche d'une charge oppos√©e

        points.push(`L${x},${y}`); // Ajout du point au chemin
        prevDir = { dx, dy };
      }

      return { pathData: points.join(" "), endPoint, length: currentLength };
    }

    // Fonction qui calcule la distance minimale d'un point aux charges positives
    function getMinDistanceFromPositiveCharges(point) {
      let minDistance = Infinity;
      charges.forEach(c => {
        if (c.visible && c.sign > 0) {
          const distance = Math.sqrt(
            (point.x - c.x) ** 2 + (point.y - c.y) ** 2
          );
          minDistance = Math.min(minDistance, distance);
        }
      });
      return minDistance;
    }

    // Fonction qui trouve la distance minimale des trajectoires positives √† leurs charges sources
    function getMinDistancePositiveTrajectoriesToCharges() {
      let minDistance = Infinity;
      positiveTrajectoryEndPoints.forEach(endPoint => {
        const distance = getMinDistanceFromPositiveCharges(endPoint);
        minDistance = Math.min(minDistance, distance);
      });
      return minDistance;
    }

    // Fonction principale qui met √† jour toutes les trajectoires
    function updatePaths() {
      // Suppression des anciens √©l√©ments graphiques
      paths.forEach(p => p.parentNode && p.parentNode.removeChild(p));
      arrows.forEach(a => a.arrow.parentNode && a.arrow.parentNode.removeChild(a.arrow));
      paths.length = 0;
      arrows.length = 0;
      positiveTrajectoryEndPoints = []; // R√©initialisation des points finaux positifs

      const positiveCharges = charges.filter(c => c.visible && c.sign > 0);
      const negativeCharges = charges.filter(c => c.visible && c.sign < 0);
      const linesPerCharge = 20; // Nombre de trajectoires par charge
      const offsetRadius = 12; // Rayon de d√©part autour des charges

      // √âTAPE 1 : Tracer d'abord toutes les trajectoires des charges positives
      positiveCharges.forEach(charge => {
        for (let i = 0; i < linesPerCharge; i++) {
          // Calcul de la position de d√©part (cercle autour de la charge)
          const angle = (2 * Math.PI * i) / linesPerCharge;
          const x = charge.x + Math.cos(angle) * offsetRadius;
          const y = charge.y + Math.sin(angle) * offsetRadius;
          
          // Tra√ßage de la trajectoire positive avec longueur maximale (120)
          const result = traceLine(x, y, charge, 120);
          positiveTrajectoryEndPoints.push(result.endPoint); // Stockage du point final
          
          // Cr√©ation du chemin SVG pour la trajectoire positive
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("d", result.pathData);
          svg.appendChild(path);
          paths.push(path);

          // Cr√©ation de la fl√®che anim√©e pour cette trajectoire
          const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
          arrow.setAttribute("class", "arrow");
          svg.appendChild(arrow);
          arrows.push({ arrow, path, isNegative: false });
        }
      });

      // √âTAPE 2 : Tracer les trajectoires des charges n√©gatives avec contrainte de distance
      if (negativeCharges.length > 0) {
        const minPositiveDistance = getMinDistancePositiveTrajectoriesToCharges(); // Distance min des positives
        
        negativeCharges.forEach(charge => {
          for (let i = 0; i < linesPerCharge; i++) {
            // Calcul de la position de d√©part (cercle autour de la charge n√©gative)
            const angle = (2 * Math.PI * i) / linesPerCharge;
            const x = charge.x + Math.cos(angle) * offsetRadius;
            const y = charge.y + Math.sin(angle) * offsetRadius;
            
            // Test de la trajectoire n√©gative compl√®te pour analyser son comportement
            const testResult = traceLine(x, y, charge, 120);
            
            // V√©rification si la trajectoire n√©gative viole la "zone positive"
            const negativeEndDistanceFromPositive = getMinDistanceFromPositiveCharges(testResult.endPoint);
            
            let maxLength = 120; // Longueur par d√©faut
            
            // Si la trajectoire n√©gative s'approche trop pr√®s des charges positives
            if (negativeEndDistanceFromPositive < minPositiveDistance) {
              // Calcul de la violation de la zone interdite
              const violation = minPositiveDistance - negativeEndDistanceFromPositive;
              const maxViolation = minPositiveDistance * 0.5; // Zone de transition
              
              if (violation >= maxViolation) {
                // Suppression compl√®te si violation trop importante
                continue;
              } else {
                // R√©duction progressive de la longueur selon la violation
                const reductionFactor = 1 - (violation / maxViolation);
                maxLength = 120 * reductionFactor;
              }
            }
            
            // Suppression des trajectoires trop courtes
            if (maxLength < 10) continue;
            
            // Tra√ßage final de la trajectoire n√©gative avec longueur ajust√©e
            const result = traceLine(x, y, charge, maxLength);
            
            // Cr√©ation du chemin SVG pour la trajectoire n√©gative
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", result.pathData);
            svg.appendChild(path);
            paths.push(path);

            // Cr√©ation de la fl√®che anim√©e pour cette trajectoire
            const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            arrow.setAttribute("class", "arrow");
            svg.appendChild(arrow);
            arrows.push({ arrow, path, isNegative: true });
          }
        });
      }
    }

    // Fonction d'animation des fl√®ches le long des trajectoires
    function animate() {
      const t = performance.now() * 0.001; // Temps actuel en secondes
      const cycleTime = 3; // Dur√©e d'un cycle complet en secondes
      
      arrows.forEach(({ arrow, path, isNegative }) => {
        if (!path || !arrow || !path.getTotalLength) return;
        const len = path.getTotalLength(); // Longueur totale du chemin
        if (len === 0) return;
        
        // Calcul de la position dans le cycle (0 √† 1)
        const cycle = (t % cycleTime) / cycleTime;
        
        let pos; // Position de la fl√®che sur le chemin
        if (isNegative) {
          // Fl√®ches n√©gatives : vont des extr√©mit√©s vers le centre (attraction)
          pos = len * (1 - cycle);
        } else {
          // Fl√®ches positives : vont du centre vers l'ext√©rieur (r√©pulsion)
          pos = len * cycle;
        }
        
        // Calcul des points pour orienter la fl√®che
        const p1 = path.getPointAtLength(pos);
        const p2 = path.getPointAtLength(isNegative ? Math.max(pos - 8, 0) : Math.min(pos + 8, len));

        // Calcul de l'angle et cr√©ation de la g√©om√©trie de la fl√®che
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        const size = 6; // Taille de la fl√®che
        const cos = Math.cos(angle), sin = Math.sin(angle);
        const ax = p1.x, ay = p1.y;

        // G√©om√©trie triangulaire de la fl√®che
        const points = [
          [ax + cos * size, ay + sin * size],           // Pointe
          [ax - sin * size * 0.5, ay + cos * size * 0.5], // Base gauche
          [ax + sin * size * 0.5, ay - cos * size * 0.5]  // Base droite
        ];
        arrow.setAttribute("points", points.map(p => p.join(",")).join(" "));
      });
      requestAnimationFrame(animate); // R√©p√©tition de l'animation
    }

    // Fonction pour permettre le d√©placement des charges √† la souris
    function setupDrag(charge) {
      let dragging = false;
      
      // D√©but du d√©placement au clic
      charge.elem.addEventListener("mousedown", (e) => {
        dragging = true;
        charge.elem.style.cursor = "grabbing"; // Changement du curseur
      });
      
      // D√©placement pendant le mouvement de la souris
      window.addEventListener("mousemove", (e) => {
        if (!dragging) return;
        const rect = svg.getBoundingClientRect();
        // Limitation des positions dans les limites du SVG avec marges
        charge.x = Math.max(20, Math.min(780, e.clientX - rect.left));
        charge.y = Math.max(20, Math.min(580, e.clientY - rect.top));
        
        // Mise √† jour de la position du cercle
        charge.elem.setAttribute("cx", charge.x);
        charge.elem.setAttribute("cy", charge.y);
        
        // Mise √† jour de la position du symbole + ou -
        charge.symbol.setAttribute("x", charge.x);
        charge.symbol.setAttribute("y", charge.y);
        
        updatePaths(); // Recalcul de toutes les trajectoires
      });
      
      // Fin du d√©placement au rel√¢chement de la souris
      window.addEventListener("mouseup", () => {
        dragging = false;
        charge.elem.style.cursor = "grab"; // Retour du curseur normal
      });
    }

    // Configuration du d√©placement pour chaque charge
    charges.forEach(setupDrag);
    
    // Fonction pour faire appara√Ætre/dispara√Ætre l'√©lectron
    function toggleElectron() {
      electronVisible = !electronVisible;
      const electron = charges[1]; // La charge n√©gative (√©lectron)
      const button = document.getElementById("toggleElectron");
      
      electron.visible = electronVisible;
      
      if(document.getElementById('next').style.display == 'none' || document.getElementById('next').style.display == ''){
        document.getElementById('toggleProton').style.display = 'block';
        document.getElementById('toggleElectron').style.display = 'none';
        electron.elem.style.display = "block";
        electron.symbol.style.display = "block";
        document.querySelector('.button-container p').textContent = "lorsqu'une charge n√©gative entre dans le champs du proton, ils subissent une attraction";

      }

        else if (electronVisible) {
        // Afficher l'√©lectron
        electron.elem.style.display = "block";
        electron.symbol.style.display = "block";
        button.textContent = "√©loigner l'√©lectron";
        $('#cheveux').css('display','block');
      } else {
        // Masquer l'√©lectron
        electron.elem.style.display = "none";
        electron.symbol.style.display = "none";
        button.textContent = "approcher un √©lectron";
      }
      
      // Mettre √† jour les trajectoires
      updatePaths();
    }
    
    // Fonction pour faire appara√Ætre/dispara√Ætre le deuxi√®me proton
    function toggleProton() {
      secondProtonVisible = !secondProtonVisible;
      const proton = charges[2]; // Le deuxi√®me proton
      const button = document.getElementById("toggleProton");
      const electron = charges[1]; // L'√©lectron
      
      proton.visible = secondProtonVisible;
      

      if(document.getElementById('next').style.display == 'none' || document.getElementById('next').style.display == ''){
        // Premier clic sur le bouton proton
        if (firstProtonClick) {
          // Faire dispara√Ætre l'√©lectron
          if (electronVisible) {
            electronVisible = false;
            electron.visible = false;
            electron.elem.style.display = "none";
            electron.symbol.style.display = "none";
          }
          firstProtonClick = false; // Marquer que le premier clic a eu lieu
        }
        
        document.getElementById('toggleElectron').style.display = 'block';
        document.getElementById('next').style.display = 'block';
        proton.elem.style.display = "block";
        proton.symbol.style.display = "block";
        document.querySelector('.button-container p').textContent = "quand une charge positive entre dans le champs d'un autre proton, les deux charges se repoussent.";
      button.textContent = "√©loigner le proton";
      }
      else if (secondProtonVisible) {
        // Afficher le proton
        proton.elem.style.display = "block";
        proton.symbol.style.display = "block";
        button.textContent = "√©loigner le proton";
        document.querySelector('.button-container p').textContent = "";

      } else {
        // Masquer le proton
        proton.elem.style.display = "none";
        proton.symbol.style.display = "none";
        button.textContent = "approcher un proton";
        document.querySelector('.button-container p').textContent = "";
        $('#cheveux').css('display','block');
      }
      
      // Mettre √† jour les trajectoires
      updatePaths();
    }
    
    // Ajout des √©v√©nements click sur les boutons
    document.getElementById("toggleElectron").addEventListener("click", toggleElectron);
    document.getElementById("toggleProton").addEventListener("click", toggleProton);
    
    // Initialisation : cr√©ation des trajectoires et d√©marrage de l'animation
    updatePaths();
    animate();



</script>
</body>
	</html>